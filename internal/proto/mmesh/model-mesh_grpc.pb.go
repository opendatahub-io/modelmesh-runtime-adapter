//
// *****************************************************************
// Copyright 2021 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// *****************************************************************

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.5
// source: model-mesh.proto

package mmesh

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ModelMesh_RegisterModel_FullMethodName   = "/mmesh.ModelMesh/registerModel"
	ModelMesh_UnregisterModel_FullMethodName = "/mmesh.ModelMesh/unregisterModel"
	ModelMesh_GetModelStatus_FullMethodName  = "/mmesh.ModelMesh/getModelStatus"
	ModelMesh_EnsureLoaded_FullMethodName    = "/mmesh.ModelMesh/ensureLoaded"
	ModelMesh_SetVModel_FullMethodName       = "/mmesh.ModelMesh/setVModel"
	ModelMesh_DeleteVModel_FullMethodName    = "/mmesh.ModelMesh/deleteVModel"
	ModelMesh_GetVModelStatus_FullMethodName = "/mmesh.ModelMesh/getVModelStatus"
)

// ModelMeshClient is the client API for ModelMesh service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// this is a grpc version of the external model-mesh interface
// for managing and serving models
type ModelMeshClient interface {
	// Registers a trained model to this model-mesh cluster
	RegisterModel(ctx context.Context, in *RegisterModelRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error)
	// Unregisters (deletes) a model from this model-mesh cluster,
	// has no effect if the specified model isn't found
	UnregisterModel(ctx context.Context, in *UnregisterModelRequest, opts ...grpc.CallOption) (*UnregisterModelResponse, error)
	// Returns the status of the specified model. See the ModelStatus enum
	GetModelStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error)
	// Ensures the model with the specified id is loaded in this model-mesh cluster
	EnsureLoaded(ctx context.Context, in *EnsureLoadedRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error)
	// Creates a new vmodel id (alias) which maps to a new or existing
	// concrete model, or sets the target model for an existing vmodel
	// to a new or existing concrete model
	SetVModel(ctx context.Context, in *SetVModelRequest, opts ...grpc.CallOption) (*VModelStatusInfo, error)
	// Deletes a vmodel, optionally deleting any referenced concrete
	// models at the same time
	DeleteVModel(ctx context.Context, in *DeleteVModelRequest, opts ...grpc.CallOption) (*DeleteVModelResponse, error)
	// Gets the status of a vmodel, including associated target/active model ids
	// If the vmodel is not found, the returned VModelStatusInfo will have empty
	// active and target model ids and an active model status of NOT_FOUND
	GetVModelStatus(ctx context.Context, in *GetVModelStatusRequest, opts ...grpc.CallOption) (*VModelStatusInfo, error)
}

type modelMeshClient struct {
	cc grpc.ClientConnInterface
}

func NewModelMeshClient(cc grpc.ClientConnInterface) ModelMeshClient {
	return &modelMeshClient{cc}
}

func (c *modelMeshClient) RegisterModel(ctx context.Context, in *RegisterModelRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelStatusInfo)
	err := c.cc.Invoke(ctx, ModelMesh_RegisterModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) UnregisterModel(ctx context.Context, in *UnregisterModelRequest, opts ...grpc.CallOption) (*UnregisterModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterModelResponse)
	err := c.cc.Invoke(ctx, ModelMesh_UnregisterModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) GetModelStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelStatusInfo)
	err := c.cc.Invoke(ctx, ModelMesh_GetModelStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) EnsureLoaded(ctx context.Context, in *EnsureLoadedRequest, opts ...grpc.CallOption) (*ModelStatusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelStatusInfo)
	err := c.cc.Invoke(ctx, ModelMesh_EnsureLoaded_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) SetVModel(ctx context.Context, in *SetVModelRequest, opts ...grpc.CallOption) (*VModelStatusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VModelStatusInfo)
	err := c.cc.Invoke(ctx, ModelMesh_SetVModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) DeleteVModel(ctx context.Context, in *DeleteVModelRequest, opts ...grpc.CallOption) (*DeleteVModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVModelResponse)
	err := c.cc.Invoke(ctx, ModelMesh_DeleteVModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelMeshClient) GetVModelStatus(ctx context.Context, in *GetVModelStatusRequest, opts ...grpc.CallOption) (*VModelStatusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VModelStatusInfo)
	err := c.cc.Invoke(ctx, ModelMesh_GetVModelStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelMeshServer is the server API for ModelMesh service.
// All implementations must embed UnimplementedModelMeshServer
// for forward compatibility.
//
// this is a grpc version of the external model-mesh interface
// for managing and serving models
type ModelMeshServer interface {
	// Registers a trained model to this model-mesh cluster
	RegisterModel(context.Context, *RegisterModelRequest) (*ModelStatusInfo, error)
	// Unregisters (deletes) a model from this model-mesh cluster,
	// has no effect if the specified model isn't found
	UnregisterModel(context.Context, *UnregisterModelRequest) (*UnregisterModelResponse, error)
	// Returns the status of the specified model. See the ModelStatus enum
	GetModelStatus(context.Context, *GetStatusRequest) (*ModelStatusInfo, error)
	// Ensures the model with the specified id is loaded in this model-mesh cluster
	EnsureLoaded(context.Context, *EnsureLoadedRequest) (*ModelStatusInfo, error)
	// Creates a new vmodel id (alias) which maps to a new or existing
	// concrete model, or sets the target model for an existing vmodel
	// to a new or existing concrete model
	SetVModel(context.Context, *SetVModelRequest) (*VModelStatusInfo, error)
	// Deletes a vmodel, optionally deleting any referenced concrete
	// models at the same time
	DeleteVModel(context.Context, *DeleteVModelRequest) (*DeleteVModelResponse, error)
	// Gets the status of a vmodel, including associated target/active model ids
	// If the vmodel is not found, the returned VModelStatusInfo will have empty
	// active and target model ids and an active model status of NOT_FOUND
	GetVModelStatus(context.Context, *GetVModelStatusRequest) (*VModelStatusInfo, error)
	mustEmbedUnimplementedModelMeshServer()
}

// UnimplementedModelMeshServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedModelMeshServer struct{}

func (UnimplementedModelMeshServer) RegisterModel(context.Context, *RegisterModelRequest) (*ModelStatusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterModel not implemented")
}
func (UnimplementedModelMeshServer) UnregisterModel(context.Context, *UnregisterModelRequest) (*UnregisterModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterModel not implemented")
}
func (UnimplementedModelMeshServer) GetModelStatus(context.Context, *GetStatusRequest) (*ModelStatusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelStatus not implemented")
}
func (UnimplementedModelMeshServer) EnsureLoaded(context.Context, *EnsureLoadedRequest) (*ModelStatusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureLoaded not implemented")
}
func (UnimplementedModelMeshServer) SetVModel(context.Context, *SetVModelRequest) (*VModelStatusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVModel not implemented")
}
func (UnimplementedModelMeshServer) DeleteVModel(context.Context, *DeleteVModelRequest) (*DeleteVModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVModel not implemented")
}
func (UnimplementedModelMeshServer) GetVModelStatus(context.Context, *GetVModelStatusRequest) (*VModelStatusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVModelStatus not implemented")
}
func (UnimplementedModelMeshServer) mustEmbedUnimplementedModelMeshServer() {}
func (UnimplementedModelMeshServer) testEmbeddedByValue()                   {}

// UnsafeModelMeshServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelMeshServer will
// result in compilation errors.
type UnsafeModelMeshServer interface {
	mustEmbedUnimplementedModelMeshServer()
}

func RegisterModelMeshServer(s grpc.ServiceRegistrar, srv ModelMeshServer) {
	// If the following call pancis, it indicates UnimplementedModelMeshServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ModelMesh_ServiceDesc, srv)
}

func _ModelMesh_RegisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).RegisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_RegisterModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).RegisterModel(ctx, req.(*RegisterModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_UnregisterModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).UnregisterModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_UnregisterModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).UnregisterModel(ctx, req.(*UnregisterModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_GetModelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).GetModelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_GetModelStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).GetModelStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_EnsureLoaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureLoadedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).EnsureLoaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_EnsureLoaded_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).EnsureLoaded(ctx, req.(*EnsureLoadedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_SetVModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).SetVModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_SetVModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).SetVModel(ctx, req.(*SetVModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_DeleteVModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).DeleteVModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_DeleteVModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).DeleteVModel(ctx, req.(*DeleteVModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelMesh_GetVModelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVModelStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelMeshServer).GetVModelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelMesh_GetVModelStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelMeshServer).GetVModelStatus(ctx, req.(*GetVModelStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ModelMesh_ServiceDesc is the grpc.ServiceDesc for ModelMesh service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModelMesh_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mmesh.ModelMesh",
	HandlerType: (*ModelMeshServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "registerModel",
			Handler:    _ModelMesh_RegisterModel_Handler,
		},
		{
			MethodName: "unregisterModel",
			Handler:    _ModelMesh_UnregisterModel_Handler,
		},
		{
			MethodName: "getModelStatus",
			Handler:    _ModelMesh_GetModelStatus_Handler,
		},
		{
			MethodName: "ensureLoaded",
			Handler:    _ModelMesh_EnsureLoaded_Handler,
		},
		{
			MethodName: "setVModel",
			Handler:    _ModelMesh_SetVModel_Handler,
		},
		{
			MethodName: "deleteVModel",
			Handler:    _ModelMesh_DeleteVModel_Handler,
		},
		{
			MethodName: "getVModelStatus",
			Handler:    _ModelMesh_GetVModelStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model-mesh.proto",
}
